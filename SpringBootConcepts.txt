go through - simpleWebApp for crud operation, basic flow , exception handling, webclient, restTemplate, 
			 myApp for dependency injection 

what are build tools

🔧 Apache Ant
Ant is a task-based build tool. You write exact instructions (like "compile these files", "copy this folder", "create this jar") in an XML file called build.xml. It gives you full control, but you must define every step manually.
Ant does not manage dependencies automatically. If you want to use external libraries (like JUnit or Gson), you need to download and manage the JARs yourself.
It's great for small or highly customized projects, or when you want fine-grained control over each step. But as the project grows, it becomes repetitive and harder to maintain.

📦 Apache Maven
Maven is a declarative, convention-based build tool. Instead of writing how to do each task, you describe what your project 
	needs (like group ID, dependencies, packaging type) in a pom.xml file.
Maven manages dependencies automatically using a central repository. You just declare the library you want, and Maven downloads
    it.
Maven expects your project to follow a standard structure, which simplifies configuration. It's better suited for larger projects
	, where consistency, automation, and dependency management matter.

🧠 When to Use What:
Use Ant if:
You need custom build steps.
Your project is small and doesn't use many dependencies.
You want full manual control.

Use Maven if:
You want automatic dependency management.
You prefer less manual setup.
You're working on a medium to large project that follows conventions.


What is Maven? - https://www.geeksforgeeks.org/what-is-maven/
Maven is a build automation tool developed using the Java programming language. It is primarily used for Java-based projects
 to manage the build process, including source code compilation, testing, packaging, and more. Maven utilizes the Project 
 Object Model (POM), where the pom.xml file describes the project’s configuration and dependency management.

Features of Maven:
The Maven Build Automation tool provides a lot of features to make the development easy. 
Below we listed them
Dependency Management: Maven simplifies the process of including third external libraries in our project and It can download 
	automatically required libraries.
Standardized Project Structure: It provides a standard project folder structure like source code in one package, testing code
	in one package, and others.
Build Life cycle: The Maven different build phases to build the project.
Plugins: It supports different plugins these are perform compilation, testing, packaging, deployment, documentation generation,
	and others.
Project Object Model: Every maven Project have parent pom.xml file which can decided the configuration and dependency 
	management of the maven project.
Central Repository: Maven uses a central repository for downloading project dependencies, which simplifies dependency 
	management.
Build Profiles: The Maven build cycle handles different profiles like development, QA, production and others
Reporting and Documentation: Maven can generate various types of project reports and documentation using plugins. These include
	Javadoc, code coverage reports, and site generation.
IDE Integration: It support different IDEs like STS, Eclipse, IntelliJ IDEA, and NetBeans.

🔁 IoC – Inversion of Control
Meaning: You give up control of creating and managing objects to the Spring container.
Instead of your code creating dependencies, Spring injects them.
Example: You don’t create new objects — Spring does it for you.
🧠 Think of it like a restaurant:
You (developer) order the dish, but the chef (Spring) cooks and serves it. You don’t control how it’s made.

🔌 DI – Dependency Injection
A type of IoC where dependencies (objects) are injected into your class.
Spring can inject dependencies via:
Constructor injection
Setter injection - 
Field injection (with annotations)

💡 Simple Analogy:
IoC = Spring is in control of creating and wiring objects.
DI = The way Spring provides those objects (dependencies) to your classes.

SpringApplication.run(MyApplication.class, args); - creates container for you, return type is ApplicationContext
Starts the Spring Boot application.
Creates the ApplicationContext (IoC container).
Performs classpath scan to find components (@Component, @Service, etc.). 
Injects dependencies using @Autowired, etc.
Starts embedded servers like Tomcat (if it's a web app).
Runs any CommandLineRunner or ApplicationRunner beans.

@Component - using this annotation on class, spring will understand that this is a class that i have to manage and spring will
 create object for you in the container.
 @Component is a Spring annotation that marks a Java class as a Spring-managed bean. This means Spring will automatically 
 detect and create an object (bean) of this class during the application startup.
 
@Autowired - @Autowired is used in Spring to automatically inject dependencies. It tells Spring, "Hey, please provide me the 
	required bean here."
	Whenever one class needs another class to function, use @Autowired to let Spring handle the wiring.
🛠 Where you can use @Autowired:
On constructors - even if not used @Autowired, it will work
On setter methods
On fields (not recommended for testability)
🔍 How it works:
Spring checks its ApplicationContext for a bean of matching type.
If found, it injects it.
If multiple candidates exist, it throws an error (unless you use @Qualifier).

@Primary - If Spring finds two or more beans of the same type, it gets confused and throws an error. @Primary solves this by 
	marking one default bean.
	
@Qualifier - Qualifier is used along with @Autowired when multiple beans of the same type exist, and you want to specify exactly
	which one to inject.
✅ Use @Qualifier when:
You have multiple beans of the same type.
You want fine control over which bean to inject.
You don't want to rely on @Primary.

@Controller - @Controller is a specialized Spring annotation used to define a class as a Spring MVC controller that handles 
web requests.
	✅ What it does:
Marks the class as a web controller.
Handles incoming HTTP requests (like GET, POST).
Returns views (HTML pages) by default 

@Controller vs @RestController:
@Controller → returns views (HTML/JSP).
@RestController → returns data (JSON/XML).

✅ Use @Controller when:
You're building a web application with views.
You want to use Thymeleaf, JSP, or other template engines.

@RequestMapping : @RequestMapping is used to map web requests (like /home, /login) to specific controller methods or classes
 in a Spring application.
 
@ResponseBody : @ResponseBody tells Spring to return the method's return value directly as the HTTP response (usually as JSON
 or plain text), instead of rendering a view (like JSP or HTML).
✅ Use Case:
You use @ResponseBody in a REST API when you want to send data (like JSON) to the client, not HTML pages.

✅ Shortcut:
If you use @RestController (instead of @Controller), you don’t need @ResponseBody on each method — it's implied automatically.
@RestController = @Controller + @ResponseBody

🔄 Spring Boot MVC Flow :
Here’s a step-by-step breakdown of how a request flows in a Spring Boot MVC web application:

🌐 1. User Sends a Request
A user hits a URL in the browser or an API client (e.g., Postman):
GET http://localhost:8080/hello

🚪 2. Embedded Server Receives Request
Spring Boot uses an embedded server (like Tomcat) that listens on port 8080 by default and receives the request.

🔀 3. DispatcherServlet Handles the Request
Spring Boot auto-configures DispatcherServlet, which acts as the front controller in the Spring MVC framework. It does the
 following:
Finds the correct controller method for the request URL.
Delegates request processing.

🎮 4. Controller Processes the Request
@RestController
public class HelloController {
    
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello from Spring Boot!";
    }
}
DispatcherServlet routes the /hello request to sayHello() method.
The method runs and returns "Hello from Spring Boot!".

📦 5. Response is Sent Back
If @ResponseBody or @RestController is used, Spring sends the return value directly as the HTTP response (e.g., plain text 
or JSON).
Otherwise, Spring would try to render a view (like an HTML page).

🧭 Flow Summary:
User Request → Embedded Server (Tomcat) → DispatcherServlet
            → Controller → Business Logic
            → Response (JSON, Text, HTML) → Back to User
			
❓ Are Spring MVC and Spring Boot MVC the same?
✅ Conceptually, YES — both use the Spring MVC framework under the hood.
❌ But technically, NO — there are differences in setup and configuration.

📌 Difference in Simple Terms:
Feature				Spring MVC								Spring Boot MVC
Configuration		Manual (XML or Java-based)				Auto-configured (almost zero setup)
Startup				Needs web.xml / servlet setup			Uses SpringApplication.run()
Dependencies		You add everything manually				Starter dependencies simplify setup
Server				Needs external server (e.g., Tomcat)	Comes with embedded server (e.g., Tomcat)
Speed to develop	Slower (more boilerplate)				Faster (minimal setup, focus on logic)


@Service - @Service is a Spring annotation used to mark a service class — a class that contains business logic.
✅ What it does:
Marks the class as a Spring-managed bean.
Makes it eligible for component scanning and dependency injection.
Semantically indicates that the class holds business logic, separating it from @Component or @Repository.
✅ When to Use @Service:
For business logic layer.
When you want to keep a clean architecture (Controller → Service → Repository).
To make the class discoverable by Spring and injectable where needed.

lombok : Lombok is a Java library that helps you reduce boilerplate code like getters, setters, constructors, and more by 
using annotations.
It auto-generates:
Getters & Setters
toString()
equals() and hashCode()
Constructor

🔧 Common Lombok Annotations:
Annotation	Purpose
@Getter / @Setter	Generates getters/setters
@Data				Combines getter, setter, toString, equals, hashCode
@NoArgsConstructor	No-arg constructor
@AllArgsConstructor	All-arg constructor
@Builder			Creates builder pattern
@Slf4j				Logger without manual setup

"
import lombok.Data;
@Data
public class User {
    private String name;
    private int age;
}
"

@PathVariable - @PathVariable is used in Spring MVC or Spring Boot to extract values from the URL path and bind them to 
	method parameters in your controller.
✅ When to Use:
When you want to extract data directly from the URL path.
For clean, RESTful URLs like /products/100 or /orders/456.

@RequestBody - @RequestBody is used to bind the body of an HTTP request (usually JSON) to a Java object in a controller method.
	@RequestBody tells Spring to convert JSON/XML → Java Object using Jackson (by default).
	Common in POST, PUT, or any request that sends data in the body.

jackson library - Jackson is a popular Java library used to convert Java objects to JSON and JSON to Java objects.
	It is the default JSON parser in Spring Boot.
🔄 In Spring Boot:
You use Jackson indirectly when you use @RequestBody, @ResponseBody, or return an object from a REST controller — Spring uses
 Jackson under the hood.
 
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping

🔌 1. JDBC (Java Database Connectivity)
A low-level Java API for directly interacting with databases using SQL.
You write SQL manually and handle connections, statements, and result sets.
"
Connection conn = DriverManager.getConnection(...);
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users");
ResultSet rs = stmt.executeQuery();
"
🟠 Cons: Verbose, repetitive, error-prone.

🏗️ 2. ORM (Object-Relational Mapping)
A concept, not a tool.
It maps Java objects to database tables and vice versa.
Helps avoid writing raw SQL.
➡️ Tools like Hibernate are ORM frameworks.

📦 3. JPA (Java Persistence API)
A standard specification (like an interface) for ORM in Java.
It defines how to map, persist, and manage Java objects with databases.
Doesn’t do anything by itself — needs a provider like Hibernate to work.

⚙️ 4. Hibernate
A popular implementation of JPA (and more).
Can work with or without JPA.
Handles object mapping, relationships, lazy loading, caching, etc.
"
@Entity
public class User {
  @Id
  private Long id;
  private String name;
}
"
🎯 Summary:
Term					What It Is				Level		Notes
JDBC					API for SQL in Java		Low-level	Manual SQL, boilerplate code
ORM						Concept					Mid-level	Mapping objects to tables
JPA						Specification (API)		High-level	Needs implementation like Hibernate
Hibernate				ORM Tool (JPA impl.)	High-level	Reduces SQL, handles persistence

🧱 Think of it like building a house:
ORM is the idea of how to build a house:
→ "Let’s match Java classes to database tables instead of writing SQL manually."

JPA is the official blueprint:
→ "Here’s a standard set of rules to follow for ORM in Java."

Hibernate is the worker that follows that blueprint:
→ "I will do the actual work for you, based on JPA rules (or even more)."

🎯 In even simpler terms:
ORM = Concept (object ↔ table)
JPA = Rules/interface
Hibernate = Tool that follows JPA to do ORM

✅ When you write code using JPA annotations, and use Spring Data JPA, behind the scenes Hibernate is doing the real work.

In-Memory Database :
An In-Memory Database is a database that stores all data directly in the system’s RAM (main memory) instead of on disk. 
This makes it much faster for read/write operations but temporary by nature.

🚀 Key Features:
Super fast (since RAM access is quicker than disk)
Temporary – data is lost when the application/server stops


🧪 H2 Database :
H2 is a lightweight, in-memory database written in Java. It is perfect for testing, prototyping, and development.

⚙️ Key Features:
🧠 In-Memory or File-based modes
🐘 Fast and easy to use
🧪 Ideal for unit tests and Spring Boot apps
💻 Comes with a web-based console (http://localhost:8080/h2-console)

✅ When to Use H2:
During local development
For integration tests
When you want a temporary database without installing anything

# application.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.jpa.show-sql=true // implemented queries will be visible in console


@Repository : @Repository is a Spring annotation used to indicate that a class provides CRUD operations (Create
	, Read, Update, Delete) on a database, typically interacting with a JPA or ORM framework like Hibernate.
	
✅ Purpose:
Marks the class as a Data Access Object (DAO)
Enables automatic exception translation (converts database exceptions into Spring’s DataAccessException)
Helps Spring detect and manage it as a bean via component scanning

📦 Example:
"
@Repository
public class UserRepository {
    
    @PersistenceContext
    private EntityManager entityManager;

    public User findById(Long id) {
        return entityManager.find(User.class, id);
    }

    public void save(User user) {
        entityManager.persist(user);
    }
}
"

Or if you're using Spring Data JPA, you usually don't even write the implementation:
"
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByName(String name);
}
"
Spring automatically provides the implementation at runtime.

🛠️ Flow Summary:
Client calls /users (GET/POST)
Controller handles the request and calls the Service
Service contains business logic and calls the Repository
Repository accesses the database
Response flows back in reverse
	
@Entity : @Entity is a JPA annotation used to mark a Java class as a database table.

It tells Spring/Hibernate:
👉 “This class should be mapped to a table in the database.”

✅ Key Features:
The class must have a no-arg constructor
It should have a primary key annotated with @Id
Used in combination with @Table, @Column, etc. (optional)

🧱 Example:
"
import jakarta.persistence.*;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Getters and setters
}
"

💡 What Happens Behind the Scenes?
Spring Boot + JPA + Hibernate will:
Create a table User in the database (if not exists)
Map each field (name, email) to a column
Handle insert, update, delete, and fetch operations

Great! Here's a quick explanation of related JPA annotations used with @Entity:

🆔 @Id
Marks the primary key of the entity (unique identifier).
"
@Id
private Long id;
"

🔢 @GeneratedValue
Specifies how the primary key should be auto-generated.
Common strategies:
@GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment (commonly used with MySQL)
@GeneratedValue(strategy = GenerationType.AUTO)     // Default (let JPA choose)
@GeneratedValue(strategy = GenerationType.SEQUENCE) // Uses a database sequence
@GeneratedValue(strategy = GenerationType.TABLE)    // Uses a table to simulate sequence

🧱 @Table (optional)
Lets you specify the table name and other details.
"
@Entity
@Table(name = "users")
public class User { ... }
"

🧩 @Column (optional)
Lets you customize each column name and behavior.
"
@Column(name = "user_name", nullable = false, length = 50)
private String name;
"

Here’s a complete example of a JPA @Entity class using @Id, @GeneratedValue, @Table, and @Column annotations:

✅ Full Example: User Entity
"
import jakarta.persistence.*;

@Entity
@Table(name = "users")  // Database table name
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment primary key
    private Long id;

    @Column(name = "user_name", nullable = false, length = 50)  // Custom column name
    private String name;

    @Column(unique = true, nullable = false)  // Email must be unique and not null
    private String email;

    @Column(name = "created_at")
    private String createdAt;

    // Constructors
    public User() {}

    public User(String name, String email, String createdAt) {
        this.name = name;
        this.email = email;
        this.createdAt = createdAt;
    }

    // Getters & Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getCreatedAt() { return createdAt; }
    public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
}
"

📌 Summary:
@Entity → Marks the class as a JPA entity.
@Table(name = "users") → Maps it to a table named users.
@Id → Primary key.
@GeneratedValue → Auto-generates ID.
@Column → Customizes the column details.



JpaRepository : JpaRepository is a Spring Data interface that provides ready-made methods for working with databases using JPA.
	It is an extension of CrudRepository and PagingAndSortingRepository and gives you full CRUD + pagination + sorting + JPA 
	features — without writing SQL or implementation code.

✅ Common Methods in JpaRepository:
You get these automatically:
save(entity) – Insert or update
findById(id) – Get entity by ID
findAll() – Get all records
deleteById(id) – Delete by ID
count() – Total number of rows
existsById(id) – Check if entity exists

📌 Example:
"
public interface UserRepository extends JpaRepository<User, Long> {
    // Custom finder method
    List<User> findByName(String name);
}
"
Spring automatically generates the implementation based on method name!

✅ Why use JpaRepository?
No boilerplate code
Built-in methods for common DB operations
Custom query support using method names or @Query

✅ @Repository vs JpaRepository
Aspect		@Repository									JpaRepository
Type		Annotation									Interface
Purpose		Marks a class as a DAO						Provides full CRUD + pagination support
Requires 	code?	Yes, you write methods manually		No, Spring generates them for you
Used for	Custom/Manual DB access classes	Standard 	Spring Data JPA repositories

ResponseEntity - ResponseEntity is a class in Spring that represents the entire HTTP response, including:
Status code (like 200 OK, 404 Not Found)
Headers
Body (the actual data or message)

Exception Handling : 
@RestControllerAdvice : @RestControllerAdvice is a Spring annotation used to handle exceptions globally across all 
	@RestController classes.
It combines two key things:
@ControllerAdvice – for global exception handling.
@ResponseBody – automatically returns the response in JSON or plain text.
✅ Why use it?
To centralize your error handling instead of repeating try-catch in every controller.


🔥 Common built-in exceptions you can use:
Exception					When to use
IllegalArgumentException	Invalid input arguments
ResponseStatusException		Custom status + message
HttpClientErrorException	For REST client calls (if applicable)
NoSuchElementException		Entity not found (like from Optional)
AccessDeniedException		Security/authentication related

do i need to add built in exceptions also in global class : You don’t need to, but you can — and often should — add built-in 
	exceptions to your global exception handler class if you want to:

✅ Why add built-in exceptions to @RestControllerAdvice?
Because if exceptions like IllegalArgumentException, ResponseStatusException, or NoSuchElementException are thrown, you may 
	want to:
Return a clean, consistent error response
Avoid exposing stack traces or technical messages
Customize status codes and messages

	
@ExceptionHandler : @ExceptionHandler is a Spring annotation used inside a controller (or globally with @RestControllerAdvice)
	to handle specific exceptions in a clean and centralized way.
🔄 Summary:
Use @ExceptionHandler to catch specific exceptions.
Place it in a controller for local handling or in @RestControllerAdvice for global handling.
Return ResponseEntity for full control over response format.

Call Another Project in spring boot

Resttemplate
Correct ✅ — RestTemplate is deprecated in Spring Boot 3.x / Spring Framework 6.x.
❌ Why you shouldn't use RestTemplate in Spring Boot 3+
It’s marked as deprecated for future development.
No new features or improvements are being added to it.
Not recommended for reactive or modern apps.

✅ Use WebClient Instead
WebClient is:
Non-blocking and reactive (but can be used in blocking mode too).
More flexible.
The official replacement for RestTemplate.

🧠 Summary
Feature				RestTemplate		WebClient
Blocking			Yes					Optional (block or not)
Deprecated?			✅ Yes in Spring 6	❌ No
Reactive support	❌ No				✅ Yes
Recommended in 3+	❌ No				✅ Yes

WebClient : 
📌 Key Differences
Feature				Synchronous (block())			Asynchronous (Mono)
Thread blocking		✅ Yes							❌ No (non-blocking)
Scalability			❌ Limited						✅ Better for many requests
Return type			String							Mono<String>
Use case			Simple/small traffic calls		High-performance systems

✅ @Configuration and @Bean in Spring (Simple Explanation)
🧩 @Configuration
It marks a class as a source of bean definitions.
Spring will scan this class and look for methods annotated with @Bean to register them in the Spring container.

🔹 Think of it as a Java-based alternative to XML configuration.
"
@Configuration
public class AppConfig {
    // This class will contain @Bean methods
}
"

🔧 @Bean
It tells Spring that the method returns a bean that should be managed by the Spring container.
The method is called only once, and the returned object is registered as a Spring bean (like a singleton).
"
@Bean
public RestTemplate restTemplate() {
    return new RestTemplate();
}
"

✅ Combined Use Example:
"
@Configuration
public class AppConfig {

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate(); // Spring will manage this bean
    }
}
"

Now you can inject RestTemplate anywhere in your project:
"
@Autowired
private RestTemplate restTemplate;
"

🎯 When to use:
Use @Configuration + @Bean when you want to explicitly define and configure beans in code.
Especially useful when:
A bean needs some custom settings
The bean is from an external library and not annotated with Spring annotations

✅ What is a Bean in Spring?
A Bean in Spring is simply an object that is managed by the Spring container.

📌 In Simple Words:
If you create a class and register it with Spring (using annotations like @Component, @Service, or via @Bean method), Spring 
	takes care of:
Creating the object (instantiation)
Managing its lifecycle
Injecting it wherever needed (@Autowired)

🧠 Example:
"
@Component
public class MyService {
    public void serve() {
        System.out.println("Service called");
    }
}
"
Now Spring knows this class is a bean. You can inject and use it:

"
@RestController
public class MyController {

    @Autowired
    private MyService myService;

    @GetMapping("/test")
    public String test() {
        myService.serve();
        return "OK";
    }
}
"

🔁 Summary:
A Spring Bean is a Java object created and managed by the Spring IoC container.
It can be auto-injected wherever needed.
You can define it via:
@Component, @Service, @Repository, @Controller
@Bean in a @Configuration class


@Configuration and @Component both register classes as Spring beans, they serve different purposes and behave differently 
	under the hood.

✅ Key Differences Between @Configuration and @Component:
🧩 1. Purpose
Annotation			Purpose
@Component			General-purpose annotation to mark a class as a Spring-managed bean (POJO/service/controller/etc.).
@Configuration		Specialized component that defines bean-producing methods using @Bean. It’s meant for configuration.

🧠 2. Proxy Behavior (CGLIB)
@Configuration classes are proxied by Spring (using CGLIB) to ensure that @Bean methods return singleton beans even when called 
	multiple times.

"
@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}
"
➡ Even if myService() is called multiple times, it returns the same singleton bean.

But with:
"
@Component
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}
"
➡ Each call to myService() may return a new instance, breaking singleton behavior.

🧪 3. Use Case
Use @Component when...												Use @Configuration when...
You're writing a regular service, controller, or repository.		You want to define beans using methods with @Bean.
You don't need to manually create other beans inside the class.		You need fine-grained control over bean creation.

✅ Summary:
@Component: Tells Spring to create an object from this class and manage it.
@Configuration: Tells Spring this class provides beans, and Spring should manage those using special proxy rules to ensure 
	singleton behavior.
	
Let’s walk through a clear example that demonstrates the singleton behavior difference between @Configuration and @Component 
	when using @Bean methods.
	
✅ 0. Common Classes
"
// Engine.java
public class Engine {
    public Engine() {
        System.out.println("Engine instance created");
    }
}
"

"
// Car.java
public class Car {
    private final Engine engine;

    public Car(Engine engine) {
        this.engine = engine;
        System.out.println("Car instance created");
    }

    public Engine getEngine() {
        return engine;
    }
}
"

✅ Example 1: Using @Configuration
"
@Configuration
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine()); // Calls the engine() method
    }
}
"
Output when used:
"
Car car = context.getBean(Car.class);
System.out.println(car.getEngine()); // Engine@123

Engine engine = context.getBean(Engine.class);
System.out.println(engine);         // Engine@123 (Same instance)
"
➡ engine() method is called once, and the same bean is reused thanks to Spring proxying the @Configuration class.

❌ Example 2: Using @Component
"
@Component
public class AppConfig {

    @Bean
    public Engine engine() {
        return new Engine();
    }

    @Bean
    public Car car() {
        return new Car(engine()); // Calls engine() directly
    }
}
"

Output when used:
"
Car car = context.getBean(Car.class);
System.out.println(car.getEngine()); // Engine@123

Engine engine = context.getBean(Engine.class);
System.out.println(engine);         // Engine@456 (Different instance!)
"
➡ engine() method is called twice, because @Component class isn’t proxied, so it doesn’t enforce singleton behavior for @Bean
 methods.

🧠 Conclusion:
Annotation			@Bean method called once?	Singleton preserved?
@Configuration		✅ Yes						✅ Yes
@Component			❌ No						❌ No




@CrossOrigin - The @CrossOrigin annotation in Spring Boot is used to enable Cross-Origin Resource Sharing (CORS) for your REST
	APIs. It allows your backend to respond to requests coming from a different domain, port, or protocol — commonly from a 
	frontend running on another server like http://localhost:4200.
✅ Basic Usage:
"
@CrossOrigin
@RestController
public class MyController {
    
    @GetMapping("/data")
    public String getData() {
        return "Hello from backend!";
    }
}
"
This allows all domains to access /data.

🔒 Restricting to Specific Origin:
"
@CrossOrigin(origins = "http://localhost:4200")
@RestController
public class MyController {
    // Only requests from localhost:4200 are allowed
}
"

🌍 On Specific Methods Only:
"
@RestController
public class MyController {

    @CrossOrigin(origins = "http://localhost:4200")
    @GetMapping("/data")
    public String getData() {
        return "Hello Angular!";
    }
}
"

⚙️ Global Configuration (for all controllers):
You can define CORS globally in a configuration class:
"
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**") // all endpoints
                .allowedOrigins("http://localhost:4200")
                .allowedMethods("GET", "POST", "PUT", "DELETE");
    }
}
"

@JsonFormat :  The @JsonFormat annotation in Jackson (used in Spring Boot) is used to control the serialization and 
	deserialization format of Java objects — especially useful for dates, times, and enums when converting to/from JSON.

✅ Common Use Case: Format a Date or LocalDateTime
"
@JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
private LocalDateTime createdAt;
"

This will ensure the createdAt field is formatted as a string in JSON like:
"
"createdAt": "2025-05-05 14:30:00"
"


@Lob : The @Lob annotation in JPA (Java Persistence API) is used to indicate that a particular field should be persisted as a 
	Large Object in the database. This is commonly used for storing large text or binary data, such as:
Long descriptions, HTML content, Images, Files, Large JSON strings

✅ Usage for Text (CLOB - Character Large Object):
"
@Lob
private String longDescription;
"
This tells JPA to store longDescription as a CLOB in the database.

✅ Usage for Binary Data (BLOB - Binary Large Object):
"
@Lob
private byte[] imageData;
"
This tells JPA to store imageData as a BLOB, suitable for storing files or images.

💡 Notes:
JPA will automatically choose CLOB for String and BLOB for byte[].
Works with databases like MySQL, PostgreSQL, Oracle, etc.
Combine with @Column for additional constraints (like nullable, length, etc.).

🧪 Example Entity:
"
@Entity
public class Product {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @Lob
    private String description;  // CLOB

    @Lob
    private byte[] image;       // BLOB
}
"


@RequestPart :  The @RequestPart annotation in Spring Boot is used when handling multipart/form-data requests, particularly 
	when a request contains both files and JSON (or form fields and files) — commonly used for uploading files along with
	metadata.

✅ When to Use @RequestPart
Use @RequestPart when:
You're handling a file upload along with non-file data.
The request is of type multipart/form-data.
You want to extract specific parts (e.g., a file, a JSON object).


MultiPartFile : MultipartFile is a Spring interface used to handle file uploads from HTML forms or HTTP requests with 
	multipart/form-data encoding.
It allows you to:
Access the file content
Get metadata like filename and content type
Save the file to disk or database

✅ Typical Use Case: Upload a File
🔧 Backend Controller:
"
@PostMapping("/upload")
public ResponseEntity<String> handleFileUpload(@RequestParam("file") MultipartFile file) {
    String fileName = file.getOriginalFilename();
    long size = file.getSize();

    // Optional: save file to disk
    try {
        file.transferTo(new File("uploads/" + fileName));
    } catch (IOException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Upload failed");
    }

    return ResponseEntity.ok("File uploaded successfully: " + fileName);
}
"

🌐 What is a Servlet?
A Servlet is a Java class that handles HTTP requests and generates responses, typically used in Java EE or Jakarta EE web 
applications.

✅ Features:
Runs on a servlet container (like Apache Tomcat)
Handles GET, POST, PUT, DELETE requests
Generates dynamic content (usually HTML or JSON)
Pure Java-based (logic-heavy)

🧪 Simple Example:
"
@WebServlet("/hello")
public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>Hello from Servlet!</h1>");
    }
}
"

📄 What is JSP (JavaServer Pages)?
JSP is a view technology that allows you to embed Java code in HTML pages to create dynamic web content — easier to use than 
servlets for generating HTML.

✅ Features:
Easier HTML generation (compared to servlet out.println)
Uses special tags like <%= %> for embedding Java
Can access request, session, and application objects directly

🧪 Simple JSP Example (hello.jsp):
"
<%@ page language="java" contentType="text/html" %>
<html>
<head><title>Hello JSP</title></head>
<body>
    <h1>Hello, <%= request.getParameter("name") %>!</h1>
</body>
</html>
"
Access it via: http://localhost:8080/your-app/hello.jsp?name=Sonali

🔁 Servlet vs JSP: Quick Comparison
Feature				Servlet									JSP
Role				Controller 								/ Logic	View / Presentation
Syntax				Pure Java								HTML + Java mixed
Code Maintenance	More verbose					Cleaner for HTML generation
Usage				Request processing, routing		Display output, UI

🎯 Modern Practice
Today, developers often use:
Servlets + JSP in legacy projects or when learning the basics
Spring Boot + Thymeleaf or Spring MVC + React/Angular in real-world applications



owasp

custom login

Behind the scene everything is servlet even the controller also

spring.security.user.name=navin
spring.security.user.password=telusko

csrf token

✅ Classpath (in Java) is:
The path that tells the Java compiler and JVM where to look for classes, packages, and resources.
In Spring Boot, you don't usually set the classpath manually — tools like Maven/Gradle handle it automatically.

✅ Run Springboot app Directly from Source Code (without building JAR)
Navigate to the directory where your pom.xml file is located, then run:
bash
mvn spring-boot:run
This will:
Compile your code.
Start the embedded server (like Tomcat).
Launch the application.

✅ Run Springboot app Using JAR (after packaging)
If you prefer to build the JAR and run it separately:

Step 1: Build the JAR
bash
mvn clean package
This creates a JAR file under the target/ directory.

Step 2: Run the JAR
bash
java -jar target/your-app-name.jar
🔹 Replace your-app-name.jar with the actual JAR file name.

✅ Run with Custom Port or Profile (Optional)
bash
mvn spring-boot:run -Dspring-boot.run.arguments="--server.port=9090 --spring.profiles.active=dev"
This runs the app on port 9090 using the dev profile.

✅ Maven Build Commands:
Command	Description
mvn clean install	Cleans, compiles, runs tests, packages, and installs to local Maven repo. # Full build + install
mvn clean package	Cleans, compiles, runs tests, and packages the app (JAR/WAR).  # Only build the JAR/WAR
mvn clean compile	Cleans and compiles only (no tests, no packaging).


🔁 1. Transaction Management – Ensures Data Consistency
Transaction Management in Spring ensures that a set of operations (e.g., database CRUD) are executed as a single atomic unit
	— either all succeed, or all fail and roll back.

✅ Example:
@Transactional
public void transferMoney(Account a, Account b, double amount) {
    a.setBalance(a.getBalance() - amount);
    b.setBalance(b.getBalance() + amount);
    accountRepository.save(a);
    accountRepository.save(b);
}
If an exception happens during any save, all changes are rolled back.

🔑 Key Features:
Uses @Transactional
Mostly used in CRUD operations
Ensures ACID properties
Real-time operations (called per request)
Involves small to medium data volumes

⚙️ 2. Batch Processing – Handling Large Volumes of Data
Batch Processing refers to automated, scheduled processing of large amounts of data — usually in chunks, often without user
 interaction.

✅ Example:
Using Spring Batch, you read data → process it → write output.

@Bean
public Job importUserJob(JobBuilderFactory jobs, Step step) {
    return jobs.get("importUserJob")
               .flow(step)
               .end()
               .build();
}
🔑 Key Features:
Uses Spring Batch
Processes millions of records
Supports chunking, retries, skipping, parallel steps
Runs on a schedule or trigger (e.g. daily ETL)
Has built-in support for restartability, job tracking

🆚 Side-by-Side Comparison
Feature				Transaction Management				Batch Processing (Spring Batch)
Purpose				Ensure atomicity of operations		Handle large data volumes in bulk
Scope				Small unit (e.g., one user action)	Big jobs (e.g., import millions of rows)
Speed				Near real-time						Often time-consuming, but scheduled
Example Use Case	Money transfer, user signup			Importing CSV, sending bulk emails
Framework			Spring Core (@Transactional)		Spring Batch
Rollback support	✅ Yes (auto rollback on failure)	✅ Yes (per chunk or job)
Error handling		Throws exceptions					Retry, skip, restart

🧠 Final Tip:
Use Transaction Management when you're doing business operations where consistency is critical.
Use Batch Processing when dealing with high-volume background jobs like file import/export, data migration, or cleanup.


🔒 What is a Persistent Object?
A persistent object is an object whose state is stored in a database (or some other storage) and can survive beyond the life
 of the application.

In simpler terms:
It's a Java object that is linked to a database row.
Any changes you make to this object will be tracked and saved to the database when a transaction is committed.

🧠 Real-Life Analogy
Imagine you fill a form in a mobile app:
Before saving = it's just a Java object (transient).
After you press Save, it goes into the database — now it's persistent.
You can later load and update it — it's still a persistent object.

✅ Example in Spring Boot using JPA
1. Entity class
@Entity
public class User {
    @Id
    private Long id;
    private String name;
}

2. Making a persistent object
@Autowired
private EntityManager entityManager;

public void saveUser() {
    User user = new User();
    user.setId(1L);
    user.setName("Sonali");

    entityManager.persist(user); // 👈 Now it's persistent!
}
After persist(), the object becomes managed by JPA, and its state is synchronized with the database.

🧾 Object States in JPA
State		Description
Transient	New object, not stored in DB yet
Persistent	Managed by JPA, linked to a DB row
Detached	Was persistent, but not being managed anymore (e.g., after session close)
Removed		Marked for deletion from DB

✅ Persistent Object Characteristics:
Stored in DB
Managed by JPA/Hibernate
Automatically synchronized with the DB inside a transaction
Changes are tracked (dirty checking)

📌 Example of Tracking:
@Transactional
public void updateUser() {
    User user = entityManager.find(User.class, 1L); // persistent object
    user.setName("Sonali Nehere"); // Hibernate tracks this change
    // No need to call save — it will auto-update at commit
}


1. JDBC
What it is: Low-level API (Java Database Connectivity).
Usage: You write SQL queries manually (SELECT, INSERT, etc.), manage connections, statements, and result sets.
Spring Boot: Not required. JDBC works directly with plain Java.

2. JPA (Java Persistence API)
What it is: A specification (just rules & interfaces).
It doesn’t have its own implementation. You cannot "use JPA" directly. You need a provider (implementation).

3. Hibernate
What it is: An implementation of JPA (plus its own features).
It provides ORM (Object Relational Mapping).
When you use @Entity, @Id, etc., that’s JPA annotations, but Hibernate is doing the actual work under the hood.

✅ So yes, Hibernate is a JPA implementation (the most popular one).
You can use Hibernate as pure Hibernate (using its Session API, SessionFactory, etc.).
Or you can use it as a JPA provider (using EntityManager, PersistenceUnit, etc.).

4. Spring Boot
Just makes life easier: config, connection pooling, repositories, transactions, etc.
But JDBC, JPA, Hibernate can all be used without Spring Boot.

👉 So:
JDBC = No ORM, manual SQL.
JPA = Just rules/specification.
Hibernate = ORM framework & JPA implementation.

Logger - 
logback bydefault in springboot
to customize logs create logback.xml
you can use log4j, slfrj also .







































