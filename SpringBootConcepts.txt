what are build tools

🔧 Apache Ant
Ant is a task-based build tool. You write exact instructions (like "compile these files", "copy this folder", "create this jar") in an XML file called build.xml. It gives you full control, but you must define every step manually.
Ant does not manage dependencies automatically. If you want to use external libraries (like JUnit or Gson), you need to download and manage the JARs yourself.
It's great for small or highly customized projects, or when you want fine-grained control over each step. But as the project grows, it becomes repetitive and harder to maintain.

📦 Apache Maven
Maven is a declarative, convention-based build tool. Instead of writing how to do each task, you describe what your project needs (like group ID, dependencies, packaging type) in a pom.xml file.
Maven manages dependencies automatically using a central repository. You just declare the library you want, and Maven downloads it.
Maven expects your project to follow a standard structure, which simplifies configuration. It's better suited for larger projects, where consistency, automation, and dependency management matter.

🧠 When to Use What:
Use Ant if:
You need custom build steps.
Your project is small and doesn't use many dependencies.
You want full manual control.

Use Maven if:
You want automatic dependency management.
You prefer less manual setup.
You're working on a medium to large project that follows conventions.


What is Maven? - https://www.geeksforgeeks.org/what-is-maven/

🔁 IoC – Inversion of Control
Meaning: You give up control of creating and managing objects to the Spring container.
Instead of your code creating dependencies, Spring injects them.
Example: You don’t create new objects — Spring does it for you.
🧠 Think of it like a restaurant:
You (developer) order the dish, but the chef (Spring) cooks and serves it. You don’t control how it’s made.

🔌 DI – Dependency Injection
A type of IoC where dependencies (objects) are injected into your class.
Spring can inject dependencies via:
Constructor injection
Setter injection - 
Field injection (with annotations)

💡 Simple Analogy:
IoC = Spring is in control of creating and wiring objects.
DI = The way Spring provides those objects (dependencies) to your classes.

SpringApplication.run(MyApplication.class, args); - creates container for you, return type is ApplicationContext
Starts the Spring Boot application.
Creates the ApplicationContext (IoC container).
Performs classpath scan to find components (@Component, @Service, etc.). 
Injects dependencies using @Autowired, etc.
Starts embedded servers like Tomcat (if it's a web app).
Runs any CommandLineRunner or ApplicationRunner beans.

@Component - using this annotation on class, spring will understand that this is a class that i have to manage and spring will
 create object for you in the container.
 @Component is a Spring annotation that marks a Java class as a Spring-managed bean. This means Spring will automatically detect
 and create an object (bean) of this class during the application startup.
 
@Autowired - @Autowired is used in Spring to automatically inject dependencies. It tells Spring, "Hey, please provide me the 
	required bean here."
	Whenever one class needs another class to function, use @Autowired to let Spring handle the wiring.
🛠 Where you can use @Autowired:
On constructors - even if not used @Autowired, it will work
On setter methods
On fields (not recommended for testability)
🔍 How it works:
Spring checks its ApplicationContext for a bean of matching type.
If found, it injects it.
If multiple candidates exist, it throws an error (unless you use @Qualifier).

@Primary - If Spring finds two or more beans of the same type, it gets confused and throws an error. @Primary solves this by 
	marking one default bean.
	
@Qualifier - Qualifier is used along with @Autowired when multiple beans of the same type exist, and you want to specify exactly
	which one to inject.
✅ Use @Qualifier when:
You have multiple beans of the same type.
You want fine control over which bean to inject.
You don't want to rely on @Primary.

@Controller - @Controller is a specialized Spring annotation used to define a class as a Spring MVC controller that handles 
web requests.
	✅ What it does:
Marks the class as a web controller.
Handles incoming HTTP requests (like GET, POST).
Returns views (HTML pages) by default 

@Controller vs @RestController:
@Controller → returns views (HTML/JSP).
@RestController → returns data (JSON/XML).

✅ Use @Controller when:
You're building a web application with views.
You want to use Thymeleaf, JSP, or other template engines.

@RequestMapping : @RequestMapping is used to map web requests (like /home, /login) to specific controller methods or classes
 in a Spring application.
 
@ResponseBody : @ResponseBody tells Spring to return the method's return value directly as the HTTP response (usually as JSON
 or plain text), instead of rendering a view (like JSP or HTML).
✅ Use Case:
You use @ResponseBody in a REST API when you want to send data (like JSON) to the client, not HTML pages.

✅ Shortcut:
If you use @RestController (instead of @Controller), you don’t need @ResponseBody on each method — it's implied automatically.
@RestController = @Controller + @ResponseBody

🔄 Spring Boot MVC Flow :
Here’s a step-by-step breakdown of how a request flows in a Spring Boot MVC web application:

🌐 1. User Sends a Request
A user hits a URL in the browser or an API client (e.g., Postman):
GET http://localhost:8080/hello

🚪 2. Embedded Server Receives Request
Spring Boot uses an embedded server (like Tomcat) that listens on port 8080 by default and receives the request.

🔀 3. DispatcherServlet Handles the Request
Spring Boot auto-configures DispatcherServlet, which acts as the front controller in the Spring MVC framework. It does the
 following:
Finds the correct controller method for the request URL.
Delegates request processing.

🎮 4. Controller Processes the Request
@RestController
public class HelloController {
    
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello from Spring Boot!";
    }
}
DispatcherServlet routes the /hello request to sayHello() method.
The method runs and returns "Hello from Spring Boot!".

📦 5. Response is Sent Back
If @ResponseBody or @RestController is used, Spring sends the return value directly as the HTTP response (e.g., plain text 
or JSON).
Otherwise, Spring would try to render a view (like an HTML page).

🧭 Flow Summary:
User Request → Embedded Server (Tomcat) → DispatcherServlet
            → Controller → Business Logic
            → Response (JSON, Text, HTML) → Back to User
			
❓ Are Spring MVC and Spring Boot MVC the same?
✅ Conceptually, YES — both use the Spring MVC framework under the hood.
❌ But technically, NO — there are differences in setup and configuration.

📌 Difference in Simple Terms:
Feature				Spring MVC								Spring Boot MVC
Configuration		Manual (XML or Java-based)				Auto-configured (almost zero setup)
Startup				Needs web.xml / servlet setup			Uses SpringApplication.run()
Dependencies		You add everything manually				Starter dependencies simplify setup
Server				Needs external server (e.g., Tomcat)	Comes with embedded server (e.g., Tomcat)
Speed to develop	Slower (more boilerplate)				Faster (minimal setup, focus on logic)


@Service - @Service is a Spring annotation used to mark a service class — a class that contains business logic.
✅ What it does:
Marks the class as a Spring-managed bean.
Makes it eligible for component scanning and dependency injection.
Semantically indicates that the class holds business logic, separating it from @Component or @Repository.
✅ When to Use @Service:
For business logic layer.
When you want to keep a clean architecture (Controller → Service → Repository).
To make the class discoverable by Spring and injectable where needed.

lombok : Lombok is a Java library that helps you reduce boilerplate code like getters, setters, constructors, and more by 
using annotations.
It auto-generates:
Getters & Setters
toString()
equals() and hashCode()
Constructor

🔧 Common Lombok Annotations:
Annotation	Purpose
@Getter / @Setter	Generates getters/setters
@Data				Combines getter, setter, toString, equals, hashCode
@NoArgsConstructor	No-arg constructor
@AllArgsConstructor	All-arg constructor
@Builder			Creates builder pattern
@Slf4j				Logger without manual setup

"
import lombok.Data;
@Data
public class User {
    private String name;
    private int age;
}
"

@PathVariable - @PathVariable is used in Spring MVC or Spring Boot to extract values from the URL path and bind them to 
	method parameters in your controller.
✅ When to Use:
When you want to extract data directly from the URL path.
For clean, RESTful URLs like /products/100 or /orders/456.

@RequestBody - @RequestBody is used to bind the body of an HTTP request (usually JSON) to a Java object in a controller method.
	@RequestBody tells Spring to convert JSON/XML → Java Object using Jackson (by default).
	pCommon in POST, PUT, or any request that sends data in the body.

jackson library













