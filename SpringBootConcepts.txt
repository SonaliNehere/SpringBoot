go through - simpleWebApp for crud operation, basic flow and exception handling, myApp for dependency injection 

what are build tools

🔧 Apache Ant
Ant is a task-based build tool. You write exact instructions (like "compile these files", "copy this folder", "create this jar") in an XML file called build.xml. It gives you full control, but you must define every step manually.
Ant does not manage dependencies automatically. If you want to use external libraries (like JUnit or Gson), you need to download and manage the JARs yourself.
It's great for small or highly customized projects, or when you want fine-grained control over each step. But as the project grows, it becomes repetitive and harder to maintain.

📦 Apache Maven
Maven is a declarative, convention-based build tool. Instead of writing how to do each task, you describe what your project 
	needs (like group ID, dependencies, packaging type) in a pom.xml file.
Maven manages dependencies automatically using a central repository. You just declare the library you want, and Maven downloads
    it.
Maven expects your project to follow a standard structure, which simplifies configuration. It's better suited for larger projects
	, where consistency, automation, and dependency management matter.

🧠 When to Use What:
Use Ant if:
You need custom build steps.
Your project is small and doesn't use many dependencies.
You want full manual control.

Use Maven if:
You want automatic dependency management.
You prefer less manual setup.
You're working on a medium to large project that follows conventions.


What is Maven? - https://www.geeksforgeeks.org/what-is-maven/

🔁 IoC – Inversion of Control
Meaning: You give up control of creating and managing objects to the Spring container.
Instead of your code creating dependencies, Spring injects them.
Example: You don’t create new objects — Spring does it for you.
🧠 Think of it like a restaurant:
You (developer) order the dish, but the chef (Spring) cooks and serves it. You don’t control how it’s made.

🔌 DI – Dependency Injection
A type of IoC where dependencies (objects) are injected into your class.
Spring can inject dependencies via:
Constructor injection
Setter injection - 
Field injection (with annotations)

💡 Simple Analogy:
IoC = Spring is in control of creating and wiring objects.
DI = The way Spring provides those objects (dependencies) to your classes.

SpringApplication.run(MyApplication.class, args); - creates container for you, return type is ApplicationContext
Starts the Spring Boot application.
Creates the ApplicationContext (IoC container).
Performs classpath scan to find components (@Component, @Service, etc.). 
Injects dependencies using @Autowired, etc.
Starts embedded servers like Tomcat (if it's a web app).
Runs any CommandLineRunner or ApplicationRunner beans.

@Component - using this annotation on class, spring will understand that this is a class that i have to manage and spring will
 create object for you in the container.
 @Component is a Spring annotation that marks a Java class as a Spring-managed bean. This means Spring will automatically detect
 and create an object (bean) of this class during the application startup.
 
@Autowired - @Autowired is used in Spring to automatically inject dependencies. It tells Spring, "Hey, please provide me the 
	required bean here."
	Whenever one class needs another class to function, use @Autowired to let Spring handle the wiring.
🛠 Where you can use @Autowired:
On constructors - even if not used @Autowired, it will work
On setter methods
On fields (not recommended for testability)
🔍 How it works:
Spring checks its ApplicationContext for a bean of matching type.
If found, it injects it.
If multiple candidates exist, it throws an error (unless you use @Qualifier).

@Primary - If Spring finds two or more beans of the same type, it gets confused and throws an error. @Primary solves this by 
	marking one default bean.
	
@Qualifier - Qualifier is used along with @Autowired when multiple beans of the same type exist, and you want to specify exactly
	which one to inject.
✅ Use @Qualifier when:
You have multiple beans of the same type.
You want fine control over which bean to inject.
You don't want to rely on @Primary.

@Controller - @Controller is a specialized Spring annotation used to define a class as a Spring MVC controller that handles 
web requests.
	✅ What it does:
Marks the class as a web controller.
Handles incoming HTTP requests (like GET, POST).
Returns views (HTML pages) by default 

@Controller vs @RestController:
@Controller → returns views (HTML/JSP).
@RestController → returns data (JSON/XML).

✅ Use @Controller when:
You're building a web application with views.
You want to use Thymeleaf, JSP, or other template engines.

@RequestMapping : @RequestMapping is used to map web requests (like /home, /login) to specific controller methods or classes
 in a Spring application.
 
@ResponseBody : @ResponseBody tells Spring to return the method's return value directly as the HTTP response (usually as JSON
 or plain text), instead of rendering a view (like JSP or HTML).
✅ Use Case:
You use @ResponseBody in a REST API when you want to send data (like JSON) to the client, not HTML pages.

✅ Shortcut:
If you use @RestController (instead of @Controller), you don’t need @ResponseBody on each method — it's implied automatically.
@RestController = @Controller + @ResponseBody

🔄 Spring Boot MVC Flow :
Here’s a step-by-step breakdown of how a request flows in a Spring Boot MVC web application:

🌐 1. User Sends a Request
A user hits a URL in the browser or an API client (e.g., Postman):
GET http://localhost:8080/hello

🚪 2. Embedded Server Receives Request
Spring Boot uses an embedded server (like Tomcat) that listens on port 8080 by default and receives the request.

🔀 3. DispatcherServlet Handles the Request
Spring Boot auto-configures DispatcherServlet, which acts as the front controller in the Spring MVC framework. It does the
 following:
Finds the correct controller method for the request URL.
Delegates request processing.

🎮 4. Controller Processes the Request
@RestController
public class HelloController {
    
    @GetMapping("/hello")
    public String sayHello() {
        return "Hello from Spring Boot!";
    }
}
DispatcherServlet routes the /hello request to sayHello() method.
The method runs and returns "Hello from Spring Boot!".

📦 5. Response is Sent Back
If @ResponseBody or @RestController is used, Spring sends the return value directly as the HTTP response (e.g., plain text 
or JSON).
Otherwise, Spring would try to render a view (like an HTML page).

🧭 Flow Summary:
User Request → Embedded Server (Tomcat) → DispatcherServlet
            → Controller → Business Logic
            → Response (JSON, Text, HTML) → Back to User
			
❓ Are Spring MVC and Spring Boot MVC the same?
✅ Conceptually, YES — both use the Spring MVC framework under the hood.
❌ But technically, NO — there are differences in setup and configuration.

📌 Difference in Simple Terms:
Feature				Spring MVC								Spring Boot MVC
Configuration		Manual (XML or Java-based)				Auto-configured (almost zero setup)
Startup				Needs web.xml / servlet setup			Uses SpringApplication.run()
Dependencies		You add everything manually				Starter dependencies simplify setup
Server				Needs external server (e.g., Tomcat)	Comes with embedded server (e.g., Tomcat)
Speed to develop	Slower (more boilerplate)				Faster (minimal setup, focus on logic)


@Service - @Service is a Spring annotation used to mark a service class — a class that contains business logic.
✅ What it does:
Marks the class as a Spring-managed bean.
Makes it eligible for component scanning and dependency injection.
Semantically indicates that the class holds business logic, separating it from @Component or @Repository.
✅ When to Use @Service:
For business logic layer.
When you want to keep a clean architecture (Controller → Service → Repository).
To make the class discoverable by Spring and injectable where needed.

lombok : Lombok is a Java library that helps you reduce boilerplate code like getters, setters, constructors, and more by 
using annotations.
It auto-generates:
Getters & Setters
toString()
equals() and hashCode()
Constructor

🔧 Common Lombok Annotations:
Annotation	Purpose
@Getter / @Setter	Generates getters/setters
@Data				Combines getter, setter, toString, equals, hashCode
@NoArgsConstructor	No-arg constructor
@AllArgsConstructor	All-arg constructor
@Builder			Creates builder pattern
@Slf4j				Logger without manual setup

"
import lombok.Data;
@Data
public class User {
    private String name;
    private int age;
}
"

@PathVariable - @PathVariable is used in Spring MVC or Spring Boot to extract values from the URL path and bind them to 
	method parameters in your controller.
✅ When to Use:
When you want to extract data directly from the URL path.
For clean, RESTful URLs like /products/100 or /orders/456.

@RequestBody - @RequestBody is used to bind the body of an HTTP request (usually JSON) to a Java object in a controller method.
	@RequestBody tells Spring to convert JSON/XML → Java Object using Jackson (by default).
	Common in POST, PUT, or any request that sends data in the body.

jackson library - Jackson is a popular Java library used to convert Java objects to JSON and JSON to Java objects.
	It is the default JSON parser in Spring Boot.
🔄 In Spring Boot:
You use Jackson indirectly when you use @RequestBody, @ResponseBody, or return an object from a REST controller — Spring uses
 Jackson under the hood.
 
@GetMapping
@PostMapping
@PutMapping
@DeleteMapping

🔌 1. JDBC (Java Database Connectivity)
A low-level Java API for directly interacting with databases using SQL.
You write SQL manually and handle connections, statements, and result sets.
"
Connection conn = DriverManager.getConnection(...);
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users");
ResultSet rs = stmt.executeQuery();
"
🟠 Cons: Verbose, repetitive, error-prone.

🏗️ 2. ORM (Object-Relational Mapping)
A concept, not a tool.
It maps Java objects to database tables and vice versa.
Helps avoid writing raw SQL.
➡️ Tools like Hibernate are ORM frameworks.

📦 3. JPA (Java Persistence API)
A standard specification (like an interface) for ORM in Java.
It defines how to map, persist, and manage Java objects with databases.
Doesn’t do anything by itself — needs a provider like Hibernate to work.

⚙️ 4. Hibernate
A popular implementation of JPA (and more).
Can work with or without JPA.
Handles object mapping, relationships, lazy loading, caching, etc.
"
@Entity
public class User {
  @Id
  private Long id;
  private String name;
}
"
🎯 Summary:
Term					What It Is				Level		Notes
JDBC					API for SQL in Java		Low-level	Manual SQL, boilerplate code
ORM						Concept					Mid-level	Mapping objects to tables
JPA						Specification (API)		High-level	Needs implementation like Hibernate
Hibernate				ORM Tool (JPA impl.)	High-level	Reduces SQL, handles persistence

🧱 Think of it like building a house:
ORM is the idea of how to build a house:
→ "Let’s match Java classes to database tables instead of writing SQL manually."

JPA is the official blueprint:
→ "Here’s a standard set of rules to follow for ORM in Java."

Hibernate is the worker that follows that blueprint:
→ "I will do the actual work for you, based on JPA rules (or even more)."

🎯 In even simpler terms:
ORM = Concept (object ↔ table)
JPA = Rules/interface
Hibernate = Tool that follows JPA to do ORM

✅ When you write code using JPA annotations, and use Spring Data JPA, behind the scenes Hibernate is doing the real work.

In-Memory Database :
An In-Memory Database is a database that stores all data directly in the system’s RAM (main memory) instead of on disk. 
This makes it much faster for read/write operations but temporary by nature.

🚀 Key Features:
Super fast (since RAM access is quicker than disk)
Temporary – data is lost when the application/server stops


🧪 H2 Database :
H2 is a lightweight, in-memory database written in Java. It is perfect for testing, prototyping, and development.

⚙️ Key Features:
🧠 In-Memory or File-based modes
🐘 Fast and easy to use
🧪 Ideal for unit tests and Spring Boot apps
💻 Comes with a web-based console (http://localhost:8080/h2-console)

✅ When to Use H2:
During local development
For integration tests
When you want a temporary database without installing anything

# application.properties
spring.datasource.url=jdbc:h2:mem:testdb
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=
spring.h2.console.enabled=true
spring.jpa.show-sql=true // implemented queries will be visible in console


@Repository : @Repository is a Spring annotation used to indicate that a class provides CRUD operations (Create
	, Read, Update, Delete) on a database, typically interacting with a JPA or ORM framework like Hibernate.
	
✅ Purpose:
Marks the class as a Data Access Object (DAO)
Enables automatic exception translation (converts database exceptions into Spring’s DataAccessException)
Helps Spring detect and manage it as a bean via component scanning

📦 Example:
"
@Repository
public class UserRepository {
    
    @PersistenceContext
    private EntityManager entityManager;

    public User findById(Long id) {
        return entityManager.find(User.class, id);
    }

    public void save(User user) {
        entityManager.persist(user);
    }
}
"

Or if you're using Spring Data JPA, you usually don't even write the implementation:
"
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    List<User> findByName(String name);
}
"
Spring automatically provides the implementation at runtime.

🛠️ Flow Summary:
Client calls /users (GET/POST)
Controller handles the request and calls the Service
Service contains business logic and calls the Repository
Repository accesses the database
Response flows back in reverse
	
@Entity : @Entity is a JPA annotation used to mark a Java class as a database table.

It tells Spring/Hibernate:
👉 “This class should be mapped to a table in the database.”

✅ Key Features:
The class must have a no-arg constructor
It should have a primary key annotated with @Id
Used in combination with @Table, @Column, etc. (optional)

🧱 Example:
"
import jakarta.persistence.*;

@Entity
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    // Getters and setters
}
"

💡 What Happens Behind the Scenes?
Spring Boot + JPA + Hibernate will:
Create a table User in the database (if not exists)
Map each field (name, email) to a column
Handle insert, update, delete, and fetch operations

Great! Here's a quick explanation of related JPA annotations used with @Entity:

🆔 @Id
Marks the primary key of the entity (unique identifier).
"
@Id
private Long id;
"

🔢 @GeneratedValue
Specifies how the primary key should be auto-generated.
Common strategies:
@GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment (commonly used with MySQL)
@GeneratedValue(strategy = GenerationType.AUTO)     // Default (let JPA choose)
@GeneratedValue(strategy = GenerationType.SEQUENCE) // Uses a database sequence
@GeneratedValue(strategy = GenerationType.TABLE)    // Uses a table to simulate sequence

🧱 @Table (optional)
Lets you specify the table name and other details.
"
@Entity
@Table(name = "users")
public class User { ... }
"

🧩 @Column (optional)
Lets you customize each column name and behavior.
"
@Column(name = "user_name", nullable = false, length = 50)
private String name;
"

Here’s a complete example of a JPA @Entity class using @Id, @GeneratedValue, @Table, and @Column annotations:

✅ Full Example: User Entity
"
import jakarta.persistence.*;

@Entity
@Table(name = "users")  // Database table name
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)  // Auto-increment primary key
    private Long id;

    @Column(name = "user_name", nullable = false, length = 50)  // Custom column name
    private String name;

    @Column(unique = true, nullable = false)  // Email must be unique and not null
    private String email;

    @Column(name = "created_at")
    private String createdAt;

    // Constructors
    public User() {}

    public User(String name, String email, String createdAt) {
        this.name = name;
        this.email = email;
        this.createdAt = createdAt;
    }

    // Getters & Setters
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getName() { return name; }
    public void setName(String name) { this.name = name; }

    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }

    public String getCreatedAt() { return createdAt; }
    public void setCreatedAt(String createdAt) { this.createdAt = createdAt; }
}
"

📌 Summary:
@Entity → Marks the class as a JPA entity.
@Table(name = "users") → Maps it to a table named users.
@Id → Primary key.
@GeneratedValue → Auto-generates ID.
@Column → Customizes the column details.



JpaRepository : JpaRepository is a Spring Data interface that provides ready-made methods for working with databases using JPA.
	It is an extension of CrudRepository and PagingAndSortingRepository and gives you full CRUD + pagination + sorting + JPA 
	features — without writing SQL or implementation code.

✅ Common Methods in JpaRepository:
You get these automatically:
save(entity) – Insert or update
findById(id) – Get entity by ID
findAll() – Get all records
deleteById(id) – Delete by ID
count() – Total number of rows
existsById(id) – Check if entity exists

📌 Example:
"
public interface UserRepository extends JpaRepository<User, Long> {
    // Custom finder method
    List<User> findByName(String name);
}
"
Spring automatically generates the implementation based on method name!

✅ Why use JpaRepository?
No boilerplate code
Built-in methods for common DB operations
Custom query support using method names or @Query

✅ @Repository vs JpaRepository
Aspect		@Repository									JpaRepository
Type		Annotation									Interface
Purpose		Marks a class as a DAO						Provides full CRUD + pagination support
Requires 	code?	Yes, you write methods manually		No, Spring generates them for you
Used for	Custom/Manual DB access classes	Standard 	Spring Data JPA repositories

ResponseEntity - ResponseEntity is a class in Spring that represents the entire HTTP response, including:
Status code (like 200 OK, 404 Not Found)
Headers
Body (the actual data or message)

Exception Handling : 
@RestControllerAdvice : @RestControllerAdvice is a Spring annotation used to handle exceptions globally across all 
@RestController classes.
It combines two key things:
@ControllerAdvice – for global exception handling.
@ResponseBody – automatically returns the response in JSON or plain text.
✅ Why use it?
To centralize your error handling instead of repeating try-catch in every controller.


🔥 Common built-in exceptions you can use:
Exception					When to use
IllegalArgumentException	Invalid input arguments
ResponseStatusException		Custom status + message
HttpClientErrorException	For REST client calls (if applicable)
NoSuchElementException		Entity not found (like from Optional)
AccessDeniedException		Security/authentication related

do i need to add built in exceptions also in global class : You don’t need to, but you can — and often should — add built-in 
	exceptions to your global exception handler class if you want to:

✅ Why add built-in exceptions to @RestControllerAdvice?
Because if exceptions like IllegalArgumentException, ResponseStatusException, or NoSuchElementException are thrown, you may 
	want to:
Return a clean, consistent error response
Avoid exposing stack traces or technical messages
Customize status codes and messages

	
@ExceptionHandler : @ExceptionHandler is a Spring annotation used inside a controller (or globally with @RestControllerAdvice) to 
	handle specific exceptions in a clean and centralized way.
🔄 Summary:
Use @ExceptionHandler to catch specific exceptions.
Place it in a controller for local handling or in @RestControllerAdvice for global handling.
Return ResponseEntity for full control over response format.

Resttemplate
























